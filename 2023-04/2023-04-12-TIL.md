# 2023년 4월 12일 TIL

# Socket기초, TCP, UDP

`4월 12일`

Socket 통신

NSStream을 사용하면 iOS에서 Socket 통신 구현이 가능함.

먼저 

## Socket 소켓이란

정규 유닉스 파일 기술자를 이용하여 다른 프로그램과 정보를 교환하는 방법

유닉스란 운영체제의 하나라고 생각할 것

유닉스에서는 모든 것이 `파일`로 취급한다.

유닉스의 프로그램들은 파일 기술자라는 것을 통해서 입출력을 한다.

여기서 파일 기술자라는 것은 

열려진 파일을 의미하는 정수 번호(index)를 말함

소켓 기술자(Socket Descriptor)라는 것은 소켓을 만들고 얻은 파일 기술자를 말한다.

- 나는 서버와 소켓통신을 하고싶다.
- 소켓을 생성해야함 → socket() 함수를 생성
- socket() 함수를 호출하면 → 내부적으로 소켓에 사용할 파일을 하나 open한다.
- 그 파일의 index 번호를 return한다.
- index 번호 = 소켓 기술자
- 소켓 기술자에 대고 send(), recv()를 하며 통신함.

소켓을 무한대로 생성해서 더 이상 파일을 열지 못하면 에러발생

소켓 기술자는 열려진 파일의 index이기 때문에, 정수형이다.

A라는 소켓을 만들고 소켓 기술자는 3 

다음 B라는 소켓을 만드면 소켓 기술자는? 

4

(파일 기술자는 0,1,2는 이미 할당되어 있어서 3부터 쓸 수 있다)

iOS에서는 소켓 통신을 위해 모든 건 프레임워크화가 되어 있음.

→ 상위레벨에서 제공하는 메서드를 갖다 쓰면 쉽게 가능함.

IP, Port만 알면 통신이 가능하다.

즉, 소켓통신은 소켓 기술자를 이용해서 send recv를 하는 통신

## TCP vs UDP

TCP (스트림 소켓)

데이터를 메세지 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다.

IP가 데이터 배달을 처리한다면,

TCP는 패킷을 추적 관리한다.

패킷이란❓

데이터를 보낼 때 한번에 보내는 것이 아닌,

효율성을 위해 조각조각 나누어서 보낸다.

여기서 `조각 나눠진 데이터를 패킷이라고 말함.`

데이터가 온전히 갔는지 확인하기 위해서

TCP는 패킷에 번호를 부여해서 패킷이 중간에 손실되진 않았는지 확인을 하고, 목적지에서는 나누어진 패킷이 다시 온전한 데이터가 될 수 있도록 재조립을 한다.

이러한 과정을 `패킷을 추적 관리`한다.를 말함

TCP 소켓의 특징

- 연결형 서비스로 안정성, 신뢰성을 보장
- 발신자와 수신자를 연결하여 논리적 경로(가상 회선 방식)을 배정
- 3-Way-Handshake방식을  통해 연결을 맺고, 4-Way Handshake를 통해 해제
- 서버가 응답을 주지 않으면 계속적으로 요청하게 된다(중도 포기가능)
- 서로 데이터를 주고받을 수 있는 양방향 통신, 일대일 통신이다.
- 패킷의 순서는 정확히 유지되고, 에러도 교정
- 데이터 흐름제어 및 혼잡 제어 가능
- UDP보다 속도가 느리다.

3-Way Handshake :

목적지와 수신지를 정확히 하여 정확한 전송을 보장하기 위해 하는 것이다.

`Ack,` 재전송으로 안정성을 제공받을 수 있음

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/740f83e6-9569-44f8-8190-579dedbe6652/Untitled.png)

TCP 패킷을 받을 때마다 Ack라는 별도의 패킷을 만들어서 보냄

Acknowledge = “ 잘 받았음 “ 이라는 뜻으로 사용

송신자가 패킷을 보내면, 수신자는

“n번 패킷 잘 받았음, n+1번 패킷 주세용”

라고 Ack보냄으로 데이터가 오가고 있음을 체크함.

`재전송`이라는 것은 Ack가 오지 않았을 때, 송신자가 패킷을 다시 보내는 작업을 말함.

Ack가 오지 않는 경우는 2개

- 수신자가 패킷을 받지 못해서 정말 Ack를 보내지 못한 것
- 수신자는 패킷을 잘 받아서 Ack를 보냈으나, Ack가 중간에 유실되어 버린 것

비효율적일 수 있으나, 데이터가 확실하게 오가는 과정을 알 수 있기 때문에 안정적이다.

`가상 회선 방식`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd2b0c5c-eec3-45c5-8c3a-918422f13a4f/Untitled.png)

패킷 1,2,3은 정해진 파란색 길으로만 간다.

이러한 파란색 길이 가상 회선(논리적 경로)가 된다.

TCP에서는 가상회선을 배정해주기 때문에, 패킷들은 이 회선을 따라 움직인다.

→패킷의 순서가 뒤바뀔일 없이 순차적으로 도착한다.

데이터 흐름 제어나 혼잡 제어 기능도 가능함.

`흐름제어` : 데이터를 송수신 하는 곳과 수신하는 곳의 데이터 처리속도를 조절하여, 수신자의 버퍼 오버플로우를 방지함.

(버퍼 오버플로우: 송신자가 데이터를 방대하게 보내면 수신자가 문제가 생길 수 있는 것)

`혼잡제어` : 네트워크 내의 패킷 수가 넘치지 않게 방지하는 것

패킷의 수가 너무 많아지면 네트워크 혼잡이 발생함.

### TCP는 기능이 많은 만큼 CPU의 부담이 커진다. 때문에 속도가 느려짐

TCP는 연속적으로 데이터를 주고받을 때보다 신뢰성있는 연결을 중시할 때 사용한다.

 연속적 데이터 = 영상같은 실시간 Streaming

---

UDP(데이터그램 소켓)

UDP에선 데이터를 데이터그램단위로 처리한다.

데이터그램: 독립적인 단계를 지니는 패킷

TCP처럼 소켓을 만들어 서로 연결을 맺는 구조가 아닌,

소켓을 만들어 그냥 UDP서버 IP, Port로 데이터를 보내는 개념

→ UDP 서버하나에 여러 Client들이 붙어서 데이터를 받을 수 있다.

TCP는 전화,

UDP는 편지

TCP는 상대방의 번호(IP, Port)로 전화를 걸고 연결이 되면, 서로 의사소통을 주고 받을 수 있다.

“잘 지내니”

“잘 못들었슴다” 

UDP는  편지이기 때문에, 상대방의 집주소(IP, Port)만 알면,

편지에 데이터를 쓰고 우체통에 넣어버리는 것

수신자는 자신의 편지통에 편지가 왔는지 직접 확인하기 전까지는 편지가 온지 모를거고,

송신자 또한 수신자가 편지를 받았는지, 안 받았는지, 중간에 잃어버렸는지 관심이없다.

UDP는 비연결형 소켓이기 때문에, 연결을 위해 할당되는 논리적 경로가 없다. 

→ 가상 회선(논리적 경로)가 없음

UDP 소켓의 특징

- 비연결형 서비스로 데이터그램 방식을 제공
- 정보를 주고받을 때, Handshake 같은 신호절차를 거치지 않음
- UDP Hedaer의 CheckSum을 통해 최소한의 에러만 검출
- 일대일 통신, 일대다 통신, 다대다 통신
- 데이터가 제대로 도착할 수도, 중간에 유실될 수도, 순서바뀌어서 도착할 수도 있다.
- TCP보다 속도가 빠름
- 신뢰성 낮음

신뢰성보다 연속성이 중요한 서비스

→ 실시간 Streaming

# Reference

[https://babbab2.tistory.com/9](https://babbab2.tistory.com/9)
