# 2023년 4월 24일 TIL

# 시간 복잡도 / 빅오 표기법

`4월 25일`

## 시간 복잡도  / 공간 복잡도

### 시간 복잡도

알고리즘의 실행 속도를 의미한다.

알고리즘이란 답이 없기 때문에 하나의 문제를 풀 때 여러가지 코드를 이용하여 풀 수 있다.

그러나 방법은 여러가지 이지만, 가장 실행 속도가 빠른 최적의 코드를 짜야하기 때문에

따라서 알고리즘을 짤 땐 이 시간 복잡도라는 것이 매우 중요하다.

```swift
var count = 10
for num in 1..<count {
    print(num)
}
```

첫 줄에서 count 변수를 선언하는 것 또한 시간 복잡도로 계산할 수 있으나 , 매우 부수적이고 크게 영향을 끼치지 않는다.

그럼 이 코드에서 가장 오래걸리는 것은 ?

count만큼 print를 반복해서 호출하는 반복문이 핵심이다.

따라서, 시간복잡도를 계산할 때 보통 핵심이 되는 것은

바로 입력에 따른 반복문이 얼만큼 반복되느냐 이다.

이 시간 복잡도를 나타내는 데 사용되는 성능 표기법이 다음과 같이 세가지가 있다.

**Big O(빅-오) 표기법 : O(N**)

알고리즘 최악의 실행 시간을 표기

아무리 최악의 상황에도, 이정도 성능은 보장한다는 의미

**Ω (오메가) 표기법 : Ω(N)**

알고리즘 최상의 실행 시간을 표기

**Θ(세타) 표기법 : Θ(N)**

알고리즘 평균 실행 시간을 표기

이 중에서 가장 많이 일반적으로 사용하는 것이

빅오 표기법이다.

### 공간 복잡도

알고리즘이 사용하는 메모리의 크기

공간 복잡도는 알고리즘이 실행될 때

메모리를 얼마나 사용하느냐를 나타내는 것이다.

근데 보통 알고리즘 할 때 시간 복잡도만 보고 공간 복잡도를 잘 보지 않는 이유는,

`메모리에 대한 발전으로 중요도가 낮아졌기 때문에 크게 신경`을 안 쓴다.

## 빅오 표기법

시간 복잡도를 나타내는 표기법

O(입력)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/69bd0539-0673-4a24-b026-3e954b57ecb5/Untitled.png)

`왼쪽 O(1)으로` 갈 수록 실행 횟수가 적은 것, 즉 `시간 복잡도가 낮은 것`

`오른쪽 O(n!)`으로 갈 수록 실행 횟수가 많은 것, 즉 `시간 복잡도가 높은 것`

### O(1)

```swift
func sayHello(n: Int) {
    print("Hello!")
}
```

위 코드는 입력 n이 어떻든 Hello 메세지를 한번만 출력한다.

따라서 n과 상관 없이 상수 1만큼 실행 되었다고 표현한다.

`입력 n과 관련이 없는 경우`

```swift
func sayHello(count: Int) {
    print("Hello!")
    print("Hello!")
    print("Hello!")
}
```

상수 3만큼 실행되었으니, O(3)이 아니라, 상수가 몇번 실행되었는지에 대해 취급하지 않고

`입력 n과 상관 없이 실행된 경우를 O(1)로 표기한다.`

### O(n)

```swift
func sayHello(n: Int) {
    for _ in 0..<n {
        print("Hello!")
    }
}
```

입력 n만큼 print출력을 반복하고 있다.

시간 복잡도에서 보통 중요한 것은 반복문 이기 때문에,

위 함수는 입력 n만큼 반복문을 실행하기 때문에

시간 복잡도를 빅오 표기법으로 표기하면 

O(n)이 된다.

```swift
func sayHello(count: Int) {
    for _ in 0..<10 {
        for _ in 0..<count {
            print("Hello!")
        }
    }
}
```

실제 실행횟수는 10n이지만, 빅오 표기법은 n만 중요하기 때문에

n앞에 어떤 상수가 붙던, 상관이 없으며, 

이미 정의된 표기법으로만 표기한다.

O(n)

### O(n^2)

```swift
func sayHello(n: Int) {
    for _ in 0..<n {
        for _ in 0..<n {
            print("Hello!")
        }
    }
}
```

반복문 두 개가 중첩되어 실행 되었는데,

반복문 두 개가 모두 입력 n에 의해 실행된다.

n이 10이면 총 100번이 실행됨.

그러므로 O(n^2)으로 표기한다.

| Complexity | 1 | 10 | 100 |
| --- | --- | --- | --- |
| O(1) | 1 | 1 | 1 |
| O(log N) | 0 | 2 | 5 |
| O(N) | 1 | 10 | 100 |
| O(N log N) | 0 | 20 | 461 |
| O(N^2) | 1 | 100 | 10000 |
| O(2^N) | 1 | 1024 | 1267650600228229401496703205376 |
| O(N!) | 1 | 3628800 | 표현 불가 |

## 시간 복잡도 예제

### 반복문을 이용한 풀이

```swift
func sum(n: Int) {
    var total = 0
    for num in 0..<n {
        total += num
    }
    print(total)
}
```

입력 n만큼 반복문이 실행되어 시간 복잡도의 경우 O(n)

### 수식을 이용한 풀이

```swift
func sum(n: Int) {
    var total = n * (n + 1) / 2
    print(total)
}
```

입력 n과 상관 없이 상수로 실행되기 때문에 O(1)이 된다.

O(n)보다 O(1)이 시간 복잡도가 낮아

반복문을 n만큼 돌리는 1번 방식보다 

수식을 이용한 2번 방식이 시간 복잡도 상 더 효율적인 코드이다.

# Reference

[https://babbab2.tistory.com/88](https://babbab2.tistory.com/88)
