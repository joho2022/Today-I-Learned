# 5️⃣ 연산자 - 복합 할당, 오버플로, 기타

`9월 8일`

## 복합 할당 연산자

할당 연산자와 다른 연산자가 하는 일을 한번에 할 수 있도록 연산자를 결합할 수 있다.

이를 복합 할당 (Compound Assignment) 연산자라고 한다.

### 복합 할당 연산자

| 표현 | 설명 | 같은 표현 |
| --- | --- | --- |
| A += B | A와 B의 합을 A에 할당한다. | A = A + B |
| A -= B | A와 B의 차를 A에 할당한다. | A = A- B |
| A *= B | A와 B의 곱을 A에 할당한다 | A = A * B |
| A /= B | A와 B로 나눈 값을 A에 할당한다. | A = A / B |
| A %= B | A를 B로 나눈 나머지를 A에 할당한다. | A = A % B |
| A <≤ N | A를 N만큼 왼쪽 비트 시프트 한 값을 A에 할당한다. | A = A << N |
| A >≥ N | A를 N만큼 오른쪽 비트 시프트 한 값을 A에 할당한다. | A = A >> N |
| A &= B | A와 B의 비트 AND 연산 결과를 A에 할당한다. | A = A & B |
| A |= B | A와 B의 비트 OR 연산 결과를 A에 할당한다. | A = A | B |
| A ^= B | A와 B의 비트 XOR 연산 결과를 A에 할당한다. | A = A ^ B |

---

## 오버플로 연산자

기존 프로그래밍 언어에서는 오버플로(또는 언더플로) 가능성이 있는 연산에 대해서는 따로 오버플로에 대한 추가 알고리즘 및 로직 등을 설계하는 것이 일반적이었다. 

스위프트는 기본 연산자를 통해 오버플로에 대비할 수 있도록 준비해두었다.

오버플로 연산자를 사용하면 오버플로를 자동으로 처리한다.

오버플로 : 컴퓨터의 정수 연산의 계산 결과가 허용 범위를 초과할 때 발생하는 오류

### 오버플로 연산자

| 연산자 | 부호 | 설명 |
| --- | --- | --- |
| 오버플로 더하기 연산 | &+ | 오버플로에 대비한 덧셈 연산을 한다. |
| 오버플로 빼기 연산 | &- | 오버플로에 대비한 뺄셈 연산을 한다. |
| 오버플로 곱하기 연산 | &* | 오버플로에 대비한 곱셈 연산을 한다. |

예를 들어 UInt8 타입은 8비트 정수 타입으로 부호가 없는 양의 정수만을 표현하기 때문에 0 아래로 내려가는 계산을 하면 런타임 오류가 발생한다.

그렇지만 오버플로 빼기 연산을 사용하면 오류 없이 오버플로 처리를 해준다.

오버플로에 대한 이해 없이 사용한다면 엉뚱한 값을 구할 수 있다.

### 오버플로 연산자의 사용

```swift
var unsignedInteger: UInt8 = 0
let errorUnderflowResult: UInt8 = unsignedInteger - 1 // 런타입 오류
let underflowedValue: UInt8 = unsignedInteger &- 1 // 255

unsignedInteger = UInt8.max
let errorOverflowResult: UInt8 = unsignedInteger + 1 // 런타입 오류
let overflowerValue: UInt8 = unsignedInteger &+ 1   // 0
```

---

## 기타 연산자

스위프트 라이브러리에 기본적으로 정의된 연산자

### 기타 연산자

| 연산자 | 부호 | 설명 |
| --- | --- | --- |
| nil 병합 연산자 | A ?? B | A가 nil이 아니면 A를 반환하고, A가 nil이면 B를 반환한다. |
| 부호변경 연산자 | -A | A의 부호를 변경한다. |
| 옵셔널 강제 추출 연산자 | O! | O(옵셔널 개체)의 값을 강제로 추출한다. |
| 옵셔널 연산자 | V? | V(옵셔널 값)를 안전하게 추출하거나, V(데이터 타입)가 옵셔널 임을 표현한다. |

### [ NOTE ] nil 병합 연산자

nil 병합 연산자는 옵셔널을 사용할 때 아주 유용한 연산자이다.

다음 두 코드는 같은 역할을 하지만, 아래의 nil 병합 연산자를 사용하는 것이 훨씬 안전하고 간단한 방법이다.

```swift
let valueInt: Int = someOptionalInt != nil ? someOptionalInt! : 0

// 위 코드와 같은 결과지만, 훨씬 안전하게 옵셔널을 다룰 수 있다.
let valueInt: Int = someOptional ?? 0
```

# Reference

야곰지음 - 스위프트 프로그래밍 3판
